<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>贪吃蛇</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  :root {
    --bg: #030a0e;
    --grid: #071520;
    --snake-head: #00ff9f;
    --snake-body: #00cc7a;
    --snake-tail: #004d2e;
    --food: #ff3f6c;
    --food-glow: rgba(255,63,108,0.6);
    --accent: #00ff9f;
    --text: #a0ffd8;
    --dim: #2a5040;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Share Tech Mono', monospace;
    color: var(--text);
    overflow: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: 
      radial-gradient(ellipse at 20% 50%, rgba(0,255,159,0.04) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 20%, rgba(0,200,120,0.03) 0%, transparent 50%);
    pointer-events: none;
  }

  h1 {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: clamp(1.5rem, 4vw, 2.5rem);
    letter-spacing: 0.3em;
    color: var(--accent);
    text-shadow: 0 0 30px rgba(0,255,159,0.5), 0 0 60px rgba(0,255,159,0.2);
    margin-bottom: 1.5rem;
    text-transform: uppercase;
  }

  .hud {
    display: flex;
    gap: 3rem;
    margin-bottom: 1.2rem;
    font-size: 0.85rem;
    letter-spacing: 0.15em;
    color: var(--dim);
  }

  .hud span { color: var(--accent); font-weight: bold; }

  .game-wrap {
    position: relative;
  }

  canvas {
    display: block;
    border: 1px solid rgba(0,255,159,0.15);
    box-shadow: 
      0 0 40px rgba(0,255,159,0.08),
      0 0 80px rgba(0,255,159,0.04),
      inset 0 0 40px rgba(0,0,0,0.5);
  }

  .overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(3,10,14,0.88);
    backdrop-filter: blur(4px);
    transition: opacity 0.3s;
  }

  .overlay.hidden { opacity: 0; pointer-events: none; }

  .overlay-title {
    font-family: 'Orbitron', monospace;
    font-size: clamp(1.2rem, 3vw, 1.8rem);
    font-weight: 700;
    color: var(--accent);
    text-shadow: 0 0 20px rgba(0,255,159,0.6);
    margin-bottom: 0.5rem;
    letter-spacing: 0.2em;
  }

  .overlay-sub {
    font-size: 0.8rem;
    color: var(--dim);
    letter-spacing: 0.1em;
    margin-bottom: 2rem;
  }

  .btn {
    font-family: 'Orbitron', monospace;
    font-size: 0.85rem;
    font-weight: 700;
    letter-spacing: 0.2em;
    color: var(--bg);
    background: var(--accent);
    border: none;
    padding: 0.8rem 2.5rem;
    cursor: pointer;
    clip-path: polygon(8px 0%, 100% 0%, calc(100% - 8px) 100%, 0% 100%);
    transition: all 0.15s;
    text-transform: uppercase;
  }

  .btn:hover {
    background: #fff;
    box-shadow: 0 0 20px rgba(0,255,159,0.6);
    transform: scale(1.04);
  }

  .tips {
    margin-top: 1rem;
    font-size: 0.72rem;
    color: var(--dim);
    letter-spacing: 0.08em;
    text-align: center;
    line-height: 1.8;
  }

  .score-flash {
    position: absolute;
    font-family: 'Orbitron', monospace;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--food);
    text-shadow: 0 0 10px var(--food-glow);
    pointer-events: none;
    animation: floatUp 0.8s ease-out forwards;
  }

  @keyframes floatUp {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-50px) scale(1.3); }
  }
</style>
</head>
<body>

<h1>贪吃蛇</h1>
<div class="hud">
  <div>分数 <span id="score">0</span></div>
  <div>最高 <span id="best">0</span></div>
  <div>速度 <span id="level">1</span></div>
</div>

<div class="game-wrap">
  <canvas id="c"></canvas>
  <div class="overlay" id="overlay">
    <div class="overlay-title" id="overlay-title">贪吃蛇</div>
    <div class="overlay-sub" id="overlay-sub">SNAKE GAME</div>
    <button class="btn" id="start-btn">开始游戏</button>
    <div class="tips">方向键 / WASD 控制方向<br>吃到食物加速成长</div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlaySub = document.getElementById('overlay-sub');
const startBtn = document.getElementById('start-btn');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const levelEl = document.getElementById('level');

const COLS = 25, ROWS = 25;
const CELL = Math.min(Math.floor(Math.min(window.innerWidth * 0.9, window.innerHeight * 0.65) / COLS), 22);
canvas.width = COLS * CELL;
canvas.height = ROWS * CELL;

let snake, dir, nextDir, food, score, best = 0, gameLoop, running = false, particles = [];

function initGame() {
  snake = [
    {x: 12, y: 12},
    {x: 11, y: 12},
    {x: 10, y: 12},
  ];
  dir = {x: 1, y: 0};
  nextDir = {x: 1, y: 0};
  score = 0;
  particles = [];
  placeFood();
  updateHUD();
}

function placeFood() {
  let pos;
  do {
    pos = {x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS)};
  } while (snake.some(s => s.x === pos.x && s.y === pos.y));
  food = pos;
  food.pulse = 0;
}

function getSpeed() {
  const lvl = Math.floor(score / 5) + 1;
  return Math.max(60, 200 - lvl * 15);
}

function getLevel() { return Math.floor(score / 5) + 1; }

function move() {
  dir = nextDir;
  const head = {x: (snake[0].x + dir.x + COLS) % COLS, y: (snake[0].y + dir.y + ROWS) % ROWS};

  if (snake.some(s => s.x === head.x && s.y === head.y)) {
    endGame(); return;
  }

  snake.unshift(head);

  if (head.x === food.x && head.y === food.y) {
    score++;
    if (score > best) best = score;
    updateHUD();
    spawnParticles(food.x, food.y);
    placeFood();
    clearInterval(gameLoop);
    gameLoop = setInterval(tick, getSpeed());
  } else {
    snake.pop();
  }
}

function tick() {
  move();
  draw();
}

function draw() {
  ctx.fillStyle = '#030a0e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = 'rgba(0,255,159,0.04)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath(); ctx.moveTo(x * CELL, 0); ctx.lineTo(x * CELL, canvas.height); ctx.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath(); ctx.moveTo(0, y * CELL); ctx.lineTo(canvas.width, y * CELL); ctx.stroke();
  }

  particles = particles.filter(p => p.life > 0);
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy; p.life -= 2; p.vy += 0.1;
    ctx.globalAlpha = p.life / 100;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.size, p.size);
    ctx.globalAlpha = 1;
  });

  food.pulse = (food.pulse || 0) + 0.08;
  const fp = (Math.sin(food.pulse) + 1) / 2;
  const fx = food.x * CELL + CELL / 2, fy = food.y * CELL + CELL / 2;
  const gr = ctx.createRadialGradient(fx, fy, 1, fx, fy, CELL * 0.7 + fp * 3);
  gr.addColorStop(0, '#ff3f6c');
  gr.addColorStop(1, 'transparent');
  ctx.fillStyle = gr;
  ctx.fillRect(food.x * CELL - CELL, food.y * CELL - CELL, CELL * 3, CELL * 3);
  ctx.fillStyle = '#ff3f6c';
  const s = CELL * 0.55 + fp * 2;
  ctx.save();
  ctx.translate(fx, fy);
  ctx.rotate(Math.PI / 4);
  ctx.fillRect(-s/2, -s/2, s, s);
  ctx.restore();

  snake.forEach((seg, i) => {
    const t = i / snake.length;
    const x = seg.x * CELL, y = seg.y * CELL;
    const size = CELL - 2;
    const pad = 1;

    if (i === 0) {
      ctx.shadowColor = 'rgba(0,255,159,0.8)';
      ctx.shadowBlur = 15;
      ctx.fillStyle = '#00ff9f';
    } else {
      ctx.shadowBlur = 0;
      const g = Math.round(255 - t * 170);
      const b = Math.round(159 - t * 113);
      ctx.fillStyle = `rgb(0,${g},${b})`;
    }

    const radius = i === 0 ? 4 : 2;
    roundRect(ctx, x + pad, y + pad, size, size, radius);
    ctx.fill();
    ctx.shadowBlur = 0;

    if (i === 0) {
      ctx.fillStyle = '#030a0e';
      const ex = dir.x === 0 ? 0 : dir.x * (CELL * 0.22);
      const ey = dir.y === 0 ? 0 : dir.y * (CELL * 0.22);
      const cx1 = x + CELL/2 + (dir.y !== 0 ? -CELL*0.18 : 0) + ex;
      const cy1 = y + CELL/2 + (dir.x !== 0 ? -CELL*0.18 : 0) + ey;
      const cx2 = x + CELL/2 + (dir.y !== 0 ? CELL*0.18 : 0) + ex;
      const cy2 = y + CELL/2 + (dir.x !== 0 ? CELL*0.18 : 0) + ey;
      ctx.beginPath(); ctx.arc(cx1, cy1, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx2, cy2, 2.5, 0, Math.PI * 2); ctx.fill();
    }
  });
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function spawnParticles(gx, gy) {
  const cx = gx * CELL + CELL / 2, cy = gy * CELL + CELL / 2;
  for (let i = 0; i < 20; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 3 + 1;
    particles.push({
      x: cx, y: cy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 2,
      life: 80 + Math.random() * 20,
      size: Math.random() * 4 + 2,
      color: Math.random() > 0.5 ? '#ff3f6c' : '#ff8fa8'
    });
  }
}

function updateHUD() {
  scoreEl.textContent = score;
  bestEl.textContent = best;
  levelEl.textContent = getLevel();
}

function endGame() {
  clearInterval(gameLoop);
  running = false;
  overlayTitle.textContent = '游戏结束';
  overlaySub.textContent = `得分: ${score}  最高: ${best}`;
  startBtn.textContent = '再来一局';
  overlay.classList.remove('hidden');
}

function startGame() {
  overlay.classList.add('hidden');
  initGame();
  running = true;
  gameLoop = setInterval(tick, getSpeed());
}

startBtn.addEventListener('click', startGame);

document.addEventListener('keydown', e => {
  const map = {
    ArrowUp: {x:0,y:-1}, ArrowDown: {x:0,y:1}, ArrowLeft: {x:-1,y:0}, ArrowRight: {x:1,y:0},
    w: {x:0,y:-1}, s: {x:0,y:1}, a: {x:-1,y:0}, d: {x:1,y:0},
    W: {x:0,y:-1}, S: {x:0,y:1}, A: {x:-1,y:0}, D: {x:1,y:0},
  };
  const nd = map[e.key];
  if (nd && !(nd.x === -dir.x && nd.y === -dir.y)) {
    nextDir = nd;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
  }
});

let touchStart = null;
canvas.addEventListener('touchstart', e => { touchStart = e.touches[0]; e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend', e => {
  if (!touchStart) return;
  const dx = e.changedTouches[0].clientX - touchStart.clientX;
  const dy = e.changedTouches[0].clientY - touchStart.clientY;
  if (Math.abs(dx) > Math.abs(dy)) {
    const nd = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
    if (!(nd.x === -dir.x)) nextDir = nd;
  } else {
    const nd = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
    if (!(nd.y === -dir.y)) nextDir = nd;
  }
  touchStart = null;
  e.preventDefault();
}, {passive:false});

ctx.fillStyle = '#030a0e';
ctx.fillRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>